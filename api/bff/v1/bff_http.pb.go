// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.7.2
// - protoc             v4.25.0
// source: bff/v1/bff.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	v1 "github.com/shiqinfeng1/goMono/api/training/v1"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationBFFApproveRescheduleTraining = "/bff.BFF/ApproveRescheduleTraining"
const OperationBFFCancelTraining = "/bff.BFF/CancelTraining"
const OperationBFFCreateTraining = "/bff.BFF/CreateTraining"
const OperationBFFGetTrainerAvailableHours = "/bff.BFF/GetTrainerAvailableHours"
const OperationBFFGetTraining = "/bff.BFF/GetTraining"
const OperationBFFMakeHourAvailable = "/bff.BFF/MakeHourAvailable"
const OperationBFFMakeHourUnavailable = "/bff.BFF/MakeHourUnavailable"
const OperationBFFRejectRescheduleTraining = "/bff.BFF/RejectRescheduleTraining"
const OperationBFFRequestRescheduleTraining = "/bff.BFF/RequestRescheduleTraining"
const OperationBFFRescheduleTraining = "/bff.BFF/RescheduleTraining"

type BFFHTTPServer interface {
	ApproveRescheduleTraining(context.Context, *v1.ApproveRescheduleTrainingRequest) (*emptypb.Empty, error)
	CancelTraining(context.Context, *v1.CancelTrainingRequest) (*emptypb.Empty, error)
	CreateTraining(context.Context, *v1.CreateTrainingRequest) (*v1.CreateTrainingResponse, error)
	GetTrainerAvailableHours(context.Context, *GetTrainerAvailableHoursRequest) (*GetTrainerAvailableHoursRespone, error)
	GetTraining(context.Context, *emptypb.Empty) (*v1.GetTrainingResponse, error)
	MakeHourAvailable(context.Context, *MakeHourAvailableRequest) (*emptypb.Empty, error)
	MakeHourUnavailable(context.Context, *MakeHourUnavailableRequest) (*emptypb.Empty, error)
	RejectRescheduleTraining(context.Context, *v1.RejectRescheduleTrainingRequest) (*emptypb.Empty, error)
	RequestRescheduleTraining(context.Context, *v1.RequestRescheduleTrainingRequest) (*emptypb.Empty, error)
	RescheduleTraining(context.Context, *v1.RescheduleTrainingRequest) (*emptypb.Empty, error)
}

func RegisterBFFHTTPServer(s *http.Server, srv BFFHTTPServer) {
	r := s.Route("/")
	r.POST("/demo/v1/trainer/getTrainerAvailableHours", _BFF_GetTrainerAvailableHours0_HTTP_Handler(srv))
	r.POST("/demo/v1/trainer/makeHourAvailable", _BFF_MakeHourAvailable0_HTTP_Handler(srv))
	r.POST("/demo/v1/trainer/makeHourUnavailable", _BFF_MakeHourUnavailable0_HTTP_Handler(srv))
	r.POST("/demo/v1/training/getTraining", _BFF_GetTraining0_HTTP_Handler(srv))
	r.POST("/demo/v1/training/createTraining", _BFF_CreateTraining0_HTTP_Handler(srv))
	r.POST("/demo/v1/training/cancelTraining", _BFF_CancelTraining0_HTTP_Handler(srv))
	r.POST("/demo/v1/training/rescheduleTraining", _BFF_RescheduleTraining0_HTTP_Handler(srv))
	r.POST("/demo/v1/training/approveRescheduleTraining", _BFF_ApproveRescheduleTraining0_HTTP_Handler(srv))
	r.POST("/demo/v1/training/requestRescheduleTraining", _BFF_RequestRescheduleTraining0_HTTP_Handler(srv))
	r.POST("/demo/v1/training/rejectRescheduleTraining", _BFF_RejectRescheduleTraining0_HTTP_Handler(srv))
}

func _BFF_GetTrainerAvailableHours0_HTTP_Handler(srv BFFHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetTrainerAvailableHoursRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBFFGetTrainerAvailableHours)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetTrainerAvailableHours(ctx, req.(*GetTrainerAvailableHoursRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetTrainerAvailableHoursRespone)
		return ctx.Result(200, reply)
	}
}

func _BFF_MakeHourAvailable0_HTTP_Handler(srv BFFHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in MakeHourAvailableRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBFFMakeHourAvailable)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.MakeHourAvailable(ctx, req.(*MakeHourAvailableRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _BFF_MakeHourUnavailable0_HTTP_Handler(srv BFFHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in MakeHourUnavailableRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBFFMakeHourUnavailable)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.MakeHourUnavailable(ctx, req.(*MakeHourUnavailableRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _BFF_GetTraining0_HTTP_Handler(srv BFFHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in emptypb.Empty
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBFFGetTraining)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetTraining(ctx, req.(*emptypb.Empty))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.GetTrainingResponse)
		return ctx.Result(200, reply)
	}
}

func _BFF_CreateTraining0_HTTP_Handler(srv BFFHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in v1.CreateTrainingRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBFFCreateTraining)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateTraining(ctx, req.(*v1.CreateTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*v1.CreateTrainingResponse)
		return ctx.Result(200, reply)
	}
}

func _BFF_CancelTraining0_HTTP_Handler(srv BFFHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in v1.CancelTrainingRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBFFCancelTraining)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CancelTraining(ctx, req.(*v1.CancelTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _BFF_RescheduleTraining0_HTTP_Handler(srv BFFHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in v1.RescheduleTrainingRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBFFRescheduleTraining)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RescheduleTraining(ctx, req.(*v1.RescheduleTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _BFF_ApproveRescheduleTraining0_HTTP_Handler(srv BFFHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in v1.ApproveRescheduleTrainingRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBFFApproveRescheduleTraining)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ApproveRescheduleTraining(ctx, req.(*v1.ApproveRescheduleTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _BFF_RequestRescheduleTraining0_HTTP_Handler(srv BFFHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in v1.RequestRescheduleTrainingRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBFFRequestRescheduleTraining)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RequestRescheduleTraining(ctx, req.(*v1.RequestRescheduleTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _BFF_RejectRescheduleTraining0_HTTP_Handler(srv BFFHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in v1.RejectRescheduleTrainingRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationBFFRejectRescheduleTraining)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RejectRescheduleTraining(ctx, req.(*v1.RejectRescheduleTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

type BFFHTTPClient interface {
	ApproveRescheduleTraining(ctx context.Context, req *v1.ApproveRescheduleTrainingRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	CancelTraining(ctx context.Context, req *v1.CancelTrainingRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	CreateTraining(ctx context.Context, req *v1.CreateTrainingRequest, opts ...http.CallOption) (rsp *v1.CreateTrainingResponse, err error)
	GetTrainerAvailableHours(ctx context.Context, req *GetTrainerAvailableHoursRequest, opts ...http.CallOption) (rsp *GetTrainerAvailableHoursRespone, err error)
	GetTraining(ctx context.Context, req *emptypb.Empty, opts ...http.CallOption) (rsp *v1.GetTrainingResponse, err error)
	MakeHourAvailable(ctx context.Context, req *MakeHourAvailableRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	MakeHourUnavailable(ctx context.Context, req *MakeHourUnavailableRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	RejectRescheduleTraining(ctx context.Context, req *v1.RejectRescheduleTrainingRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	RequestRescheduleTraining(ctx context.Context, req *v1.RequestRescheduleTrainingRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	RescheduleTraining(ctx context.Context, req *v1.RescheduleTrainingRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
}

type BFFHTTPClientImpl struct {
	cc *http.Client
}

func NewBFFHTTPClient(client *http.Client) BFFHTTPClient {
	return &BFFHTTPClientImpl{client}
}

func (c *BFFHTTPClientImpl) ApproveRescheduleTraining(ctx context.Context, in *v1.ApproveRescheduleTrainingRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/demo/v1/training/approveRescheduleTraining"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBFFApproveRescheduleTraining))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BFFHTTPClientImpl) CancelTraining(ctx context.Context, in *v1.CancelTrainingRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/demo/v1/training/cancelTraining"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBFFCancelTraining))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BFFHTTPClientImpl) CreateTraining(ctx context.Context, in *v1.CreateTrainingRequest, opts ...http.CallOption) (*v1.CreateTrainingResponse, error) {
	var out v1.CreateTrainingResponse
	pattern := "/demo/v1/training/createTraining"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBFFCreateTraining))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BFFHTTPClientImpl) GetTrainerAvailableHours(ctx context.Context, in *GetTrainerAvailableHoursRequest, opts ...http.CallOption) (*GetTrainerAvailableHoursRespone, error) {
	var out GetTrainerAvailableHoursRespone
	pattern := "/demo/v1/trainer/getTrainerAvailableHours"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBFFGetTrainerAvailableHours))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BFFHTTPClientImpl) GetTraining(ctx context.Context, in *emptypb.Empty, opts ...http.CallOption) (*v1.GetTrainingResponse, error) {
	var out v1.GetTrainingResponse
	pattern := "/demo/v1/training/getTraining"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBFFGetTraining))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BFFHTTPClientImpl) MakeHourAvailable(ctx context.Context, in *MakeHourAvailableRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/demo/v1/trainer/makeHourAvailable"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBFFMakeHourAvailable))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BFFHTTPClientImpl) MakeHourUnavailable(ctx context.Context, in *MakeHourUnavailableRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/demo/v1/trainer/makeHourUnavailable"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBFFMakeHourUnavailable))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BFFHTTPClientImpl) RejectRescheduleTraining(ctx context.Context, in *v1.RejectRescheduleTrainingRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/demo/v1/training/rejectRescheduleTraining"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBFFRejectRescheduleTraining))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BFFHTTPClientImpl) RequestRescheduleTraining(ctx context.Context, in *v1.RequestRescheduleTrainingRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/demo/v1/training/requestRescheduleTraining"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBFFRequestRescheduleTraining))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *BFFHTTPClientImpl) RescheduleTraining(ctx context.Context, in *v1.RescheduleTrainingRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/demo/v1/training/rescheduleTraining"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationBFFRescheduleTraining))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
