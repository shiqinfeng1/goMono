// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.7.1
// - protoc             v3.21.12
// source: trainings/v1/trainings.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationTrainingServiceApproveRescheduleTraining = "/trainer.TrainingService/ApproveRescheduleTraining"
const OperationTrainingServiceCancelTraining = "/trainer.TrainingService/CancelTraining"
const OperationTrainingServiceCreateTraining = "/trainer.TrainingService/CreateTraining"
const OperationTrainingServiceGetTrainings = "/trainer.TrainingService/GetTrainings"
const OperationTrainingServiceRejectRescheduleTraining = "/trainer.TrainingService/RejectRescheduleTraining"
const OperationTrainingServiceRequestRescheduleTraining = "/trainer.TrainingService/RequestRescheduleTraining"
const OperationTrainingServiceRescheduleTraining = "/trainer.TrainingService/RescheduleTraining"

type TrainingServiceHTTPServer interface {
	ApproveRescheduleTraining(context.Context, *ApproveRescheduleTrainingRequest) (*emptypb.Empty, error)
	CancelTraining(context.Context, *CancelTrainingRequest) (*emptypb.Empty, error)
	CreateTraining(context.Context, *CreateTrainingRequest) (*CreateTrainingResponse, error)
	GetTrainings(context.Context, *emptypb.Empty) (*GetTrainingsResponse, error)
	RejectRescheduleTraining(context.Context, *RejectRescheduleTrainingRequest) (*emptypb.Empty, error)
	RequestRescheduleTraining(context.Context, *RequestRescheduleTrainingRequest) (*emptypb.Empty, error)
	RescheduleTraining(context.Context, *RescheduleTrainingRequest) (*emptypb.Empty, error)
}

func RegisterTrainingServiceHTTPServer(s *http.Server, srv TrainingServiceHTTPServer) {
	r := s.Route("/")
	r.POST("/trainings/v1/getTrainings", _TrainingService_GetTrainings0_HTTP_Handler(srv))
	r.POST("/trainings/v1/createTraining", _TrainingService_CreateTraining0_HTTP_Handler(srv))
	r.POST("/trainings/v1/cancelTraining", _TrainingService_CancelTraining0_HTTP_Handler(srv))
	r.POST("/trainings/v1/rescheduleTraining", _TrainingService_RescheduleTraining0_HTTP_Handler(srv))
	r.POST("/trainings/v1/approveRescheduleTraining", _TrainingService_ApproveRescheduleTraining0_HTTP_Handler(srv))
	r.POST("/trainings/v1/requestRescheduleTraining", _TrainingService_RequestRescheduleTraining0_HTTP_Handler(srv))
	r.POST("/trainings/v1/rejectRescheduleTraining", _TrainingService_RejectRescheduleTraining0_HTTP_Handler(srv))
}

func _TrainingService_GetTrainings0_HTTP_Handler(srv TrainingServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in emptypb.Empty
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTrainingServiceGetTrainings)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetTrainings(ctx, req.(*emptypb.Empty))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetTrainingsResponse)
		return ctx.Result(200, reply)
	}
}

func _TrainingService_CreateTraining0_HTTP_Handler(srv TrainingServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateTrainingRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTrainingServiceCreateTraining)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateTraining(ctx, req.(*CreateTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateTrainingResponse)
		return ctx.Result(200, reply)
	}
}

func _TrainingService_CancelTraining0_HTTP_Handler(srv TrainingServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CancelTrainingRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTrainingServiceCancelTraining)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CancelTraining(ctx, req.(*CancelTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _TrainingService_RescheduleTraining0_HTTP_Handler(srv TrainingServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RescheduleTrainingRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTrainingServiceRescheduleTraining)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RescheduleTraining(ctx, req.(*RescheduleTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _TrainingService_ApproveRescheduleTraining0_HTTP_Handler(srv TrainingServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ApproveRescheduleTrainingRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTrainingServiceApproveRescheduleTraining)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ApproveRescheduleTraining(ctx, req.(*ApproveRescheduleTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _TrainingService_RequestRescheduleTraining0_HTTP_Handler(srv TrainingServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RequestRescheduleTrainingRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTrainingServiceRequestRescheduleTraining)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RequestRescheduleTraining(ctx, req.(*RequestRescheduleTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

func _TrainingService_RejectRescheduleTraining0_HTTP_Handler(srv TrainingServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RejectRescheduleTrainingRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationTrainingServiceRejectRescheduleTraining)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RejectRescheduleTraining(ctx, req.(*RejectRescheduleTrainingRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*emptypb.Empty)
		return ctx.Result(200, reply)
	}
}

type TrainingServiceHTTPClient interface {
	ApproveRescheduleTraining(ctx context.Context, req *ApproveRescheduleTrainingRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	CancelTraining(ctx context.Context, req *CancelTrainingRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	CreateTraining(ctx context.Context, req *CreateTrainingRequest, opts ...http.CallOption) (rsp *CreateTrainingResponse, err error)
	GetTrainings(ctx context.Context, req *emptypb.Empty, opts ...http.CallOption) (rsp *GetTrainingsResponse, err error)
	RejectRescheduleTraining(ctx context.Context, req *RejectRescheduleTrainingRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	RequestRescheduleTraining(ctx context.Context, req *RequestRescheduleTrainingRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
	RescheduleTraining(ctx context.Context, req *RescheduleTrainingRequest, opts ...http.CallOption) (rsp *emptypb.Empty, err error)
}

type TrainingServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewTrainingServiceHTTPClient(client *http.Client) TrainingServiceHTTPClient {
	return &TrainingServiceHTTPClientImpl{client}
}

func (c *TrainingServiceHTTPClientImpl) ApproveRescheduleTraining(ctx context.Context, in *ApproveRescheduleTrainingRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/trainings/v1/approveRescheduleTraining"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationTrainingServiceApproveRescheduleTraining))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TrainingServiceHTTPClientImpl) CancelTraining(ctx context.Context, in *CancelTrainingRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/trainings/v1/cancelTraining"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationTrainingServiceCancelTraining))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TrainingServiceHTTPClientImpl) CreateTraining(ctx context.Context, in *CreateTrainingRequest, opts ...http.CallOption) (*CreateTrainingResponse, error) {
	var out CreateTrainingResponse
	pattern := "/trainings/v1/createTraining"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationTrainingServiceCreateTraining))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TrainingServiceHTTPClientImpl) GetTrainings(ctx context.Context, in *emptypb.Empty, opts ...http.CallOption) (*GetTrainingsResponse, error) {
	var out GetTrainingsResponse
	pattern := "/trainings/v1/getTrainings"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationTrainingServiceGetTrainings))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TrainingServiceHTTPClientImpl) RejectRescheduleTraining(ctx context.Context, in *RejectRescheduleTrainingRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/trainings/v1/rejectRescheduleTraining"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationTrainingServiceRejectRescheduleTraining))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TrainingServiceHTTPClientImpl) RequestRescheduleTraining(ctx context.Context, in *RequestRescheduleTrainingRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/trainings/v1/requestRescheduleTraining"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationTrainingServiceRequestRescheduleTraining))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *TrainingServiceHTTPClientImpl) RescheduleTraining(ctx context.Context, in *RescheduleTrainingRequest, opts ...http.CallOption) (*emptypb.Empty, error) {
	var out emptypb.Empty
	pattern := "/trainings/v1/rescheduleTraining"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationTrainingServiceRescheduleTraining))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
